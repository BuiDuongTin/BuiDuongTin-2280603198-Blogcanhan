<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hiểu sâu về Java Collections Framework và hiệu suất - Bùi Dương Tin</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
</head>
<body>
    <!-- Header & Navigation -->
    <header>
        <div class="container">
            <div class="logo">
                <a href="../index.html">BDT<span>Code</span></a>
            </div>
            <nav>
                <ul class="nav-links">
                    <li><a href="../index.html">Trang chủ</a></li>
                    <li><a href="../blog.html" class="active">Blog</a></li>
                </ul>
                <div class="hamburger">
                    <div class="line"></div>
                    <div class="line"></div>
                    <div class="line"></div>
                </div>
            </nav>
        </div>
    </header>

    <!-- Post Header -->
    <section class="post-header">
        <div class="container">
            <h1>Hiểu sâu về Java Collections Framework và hiệu suất</h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> 15/09/2025</span>
                <span><i class="far fa-clock"></i> 14 phút đọc</span>
                <span><i class="far fa-folder"></i> Java</span>
            </div>
        </div>
    </section>

    <!-- Post Content -->
    <section class="post-content">
        <div class="container">
            <div class="post-image">
                <img src="../images/post-6.jpg" alt="Java Collections Framework">
            </div>
            
            <div class="content">
                <h2>Giới thiệu về Java Collections Framework</h2>
                <p>
                    Java Collections Framework (JCF) là một kiến trúc thống nhất để biểu diễn và thao tác với các tập hợp, 
                    cho phép chúng được thao tác độc lập với các chi tiết triển khai cụ thể. JCF được giới thiệu từ Java 1.2 và 
                    đã trở thành một phần không thể thiếu trong phát triển ứng dụng Java.
                </p>
                
                <p>
                    Hiểu rõ về JCF và hiệu suất của các cấu trúc dữ liệu trong đó sẽ giúp bạn lựa chọn đúng cấu trúc dữ liệu 
                    cho từng tình huống, tối ưu hóa ứng dụng và giải quyết vấn đề hiệu quả hơn.
                </p>

                <h2>Tổng quan về các Interface chính</h2>
                <p>
                    JCF được xây dựng xung quanh một tập các interface, các lớp triển khai cụ thể và các thuật toán. 
                    Các interface chính bao gồm:
                </p>
                
                <ul>
                    <li><strong>Collection</strong>: Interface gốc của framework, định nghĩa các thao tác cơ bản cho tất cả các collections</li>
                    <li><strong>Set</strong>: Collection không chứa các phần tử trùng lặp</li>
                    <li><strong>List</strong>: Collection có thứ tự, cho phép truy cập các phần tử bằng chỉ số (index)</li>
                    <li><strong>Queue</strong>: Collection được thiết kế cho việc xử lý các phần tử trước khi chúng được xử lý</li>
                    <li><strong>Deque</strong>: Collection hỗ trợ chèn và lấy phần tử từ cả hai đầu</li>
                    <li><strong>Map</strong>: Ánh xạ các khóa (key) với giá trị (value), không cho phép khóa trùng lặp</li>
                </ul>
                
                <p>
                    Hình sau minh họa hệ thống phân cấp của JCF:
                </p>
                
                <div style="text-align: center; margin: 20px 0;">
                    <img src="../images/java-collections-hierarchy.png" alt="Java Collections Hierarchy" style="max-width: 600px; margin: 0 auto;">
                    <p style="font-style: italic; margin-top: 10px;">Hình 1: Phân cấp Java Collections Framework</p>
                </div>
                
                <h2>List và các triển khai</h2>
                <p>
                    Interface List đại diện cho một tập hợp có thứ tự (ordered) và cho phép phần tử trùng lặp. 
                    Các lớp triển khai phổ biến của List là:
                </p>
                
                <h3>ArrayList</h3>
                <p>
                    ArrayList là triển khai của List dựa trên mảng động. Nó cho phép truy cập ngẫu nhiên nhanh chóng 
                    nhưng chèn/xóa phần tử ở giữa mảng có thể chậm do cần phải dịch chuyển các phần tử.
                </p>
                
                <pre><code class="language-java">
import java.util.ArrayList;
import java.util.List;

public class ArrayListExample {
    public static void main(String[] args) {
        // Khởi tạo ArrayList
        List<String> fruits = new ArrayList<>();
        
        // Thêm phần tử
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");
        
        // Truy cập theo index
        System.out.println("Element at index 1: " + fruits.get(1));
        
        // Duyệt qua các phần tử
        System.out.println("All fruits:");
        for (String fruit : fruits) {
            System.out.println(fruit);
        }
        
        // Chèn phần tử vào vị trí cụ thể
        fruits.add(1, "Mango");
        System.out.println("After insertion: " + fruits);
        
        // Xóa phần tử
        fruits.remove("Banana");
        System.out.println("After removal: " + fruits);
        
        // Kiểm tra phần tử tồn tại
        boolean containsApple = fruits.contains("Apple");
        System.out.println("Contains Apple? " + containsApple);
        
        // Kích thước
        System.out.println("Size: " + fruits.size());
    }
}
                </code></pre>
                
                <h3>LinkedList</h3>
                <p>
                    LinkedList triển khai List và Deque interface, sử dụng danh sách liên kết đôi. Nó cung cấp hiệu suất tốt 
                    cho thao tác chèn/xóa ở đầu, cuối hoặc giữa danh sách, nhưng truy cập ngẫu nhiên chậm hơn ArrayList.
                </p>
                
                <pre><code class="language-java">
import java.util.LinkedList;

public class LinkedListExample {
    public static void main(String[] args) {
        LinkedList<String> linkedList = new LinkedList<>();
        
        // Thêm phần tử
        linkedList.add("A");
        linkedList.add("B");
        
        // Thêm vào đầu và cuối
        linkedList.addFirst("First");
        linkedList.addLast("Last");
        
        System.out.println("LinkedList: " + linkedList);
        
        // Lấy phần tử đầu và cuối (không xóa)
        String first = linkedList.getFirst();
        String last = linkedList.getLast();
        System.out.println("First: " + first + ", Last: " + last);
        
        // Lấy và xóa phần tử đầu và cuối
        String removedFirst = linkedList.removeFirst();
        String removedLast = linkedList.removeLast();
        System.out.println("Removed First: " + removedFirst + ", Removed Last: " + removedLast);
        
        System.out.println("After removal: " + linkedList);
    }
}
                </code></pre>
                
                <h3>Vector và Stack</h3>
                <p>
                    Vector tương tự như ArrayList nhưng được đồng bộ hóa (synchronized). Stack kế thừa từ Vector và triển khai 
                    mô hình Last-In-First-Out (LIFO). Tuy nhiên, các lớp này đã lỗi thời và thường được thay thế bằng ArrayList và 
                    các triển khai của Deque.
                </p>
                
                <h3>So sánh hiệu suất giữa ArrayList và LinkedList</h3>
                <table border="1" style="width:100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background-color: #f8f9fa;">
                        <th style="padding: 10px; text-align: left;">Thao tác</th>
                        <th style="padding: 10px; text-align: left;">ArrayList</th>
                        <th style="padding: 10px; text-align: left;">LinkedList</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">Truy cập ngẫu nhiên (get/set)</td>
                        <td style="padding: 10px;">O(1)</td>
                        <td style="padding: 10px;">O(n)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">Thêm/xóa ở cuối</td>
                        <td style="padding: 10px;">O(1)* (trung bình)</td>
                        <td style="padding: 10px;">O(1)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">Thêm/xóa ở đầu</td>
                        <td style="padding: 10px;">O(n)</td>
                        <td style="padding: 10px;">O(1)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">Thêm/xóa ở giữa</td>
                        <td style="padding: 10px;">O(n)</td>
                        <td style="padding: 10px;">O(n) (cần tìm vị trí trước)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">Tìm kiếm</td>
                        <td style="padding: 10px;">O(n)</td>
                        <td style="padding: 10px;">O(n)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">Sử dụng bộ nhớ</td>
                        <td style="padding: 10px;">Ít hơn</td>
                        <td style="padding: 10px;">Nhiều hơn (lưu trữ tham chiếu)</td>
                    </tr>
                </table>
                
                <p>
                    * Thao tác add() trên ArrayList thường là O(1), nhưng có thể là O(n) khi mảng cần được mở rộng.
                </p>
                
                <h2>Set và các triển khai</h2>
                <p>
                    Interface Set đại diện cho một tập hợp không chứa các phần tử trùng lặp. Các triển khai phổ biến bao gồm:
                </p>
                
                <h3>HashSet</h3>
                <p>
                    HashSet lưu trữ các phần tử trong bảng băm (hash table). Nó không đảm bảo thứ tự các phần tử, nhưng 
                    cung cấp hiệu suất hằng số cho các thao tác cơ bản (add, remove, contains).
                </p>
                
                <pre><code class="language-java">
import java.util.HashSet;
import java.util.Set;

public class HashSetExample {
    public static void main(String[] args) {
        Set<String> hashSet = new HashSet<>();
        
        // Thêm phần tử
        hashSet.add("Apple");
        hashSet.add("Banana");
        hashSet.add("Orange");
        hashSet.add("Apple"); // Phần tử trùng lặp - sẽ bị bỏ qua
        
        System.out.println("HashSet: " + hashSet);
        System.out.println("Size: " + hashSet.size());
        
        // Kiểm tra phần tử
        boolean containsApple = hashSet.contains("Apple");
        System.out.println("Contains Apple? " + containsApple);
        
        // Xóa phần tử
        hashSet.remove("Banana");
        System.out.println("After removal: " + hashSet);
        
        // Duyệt qua các phần tử
        System.out.println("Iterating through HashSet:");
        for (String item : hashSet) {
            System.out.println(item);
        }
        
        // Xóa tất cả phần tử
        hashSet.clear();
        System.out.println("After clear: " + hashSet);
    }
}
                </code></pre>
                
                <h3>LinkedHashSet</h3>
                <p>
                    LinkedHashSet kế thừa từ HashSet nhưng duy trì thứ tự chèn (insertion order) thông qua danh sách liên kết đôi 
                    chạy qua tất cả các mục. Nó chậm hơn một chút so với HashSet nhưng nhanh hơn TreeSet.
                </p>
                
                <pre><code class="language-java">
import java.util.LinkedHashSet;
import java.util.Set;

public class LinkedHashSetExample {
    public static void main(String[] args) {
        Set<String> linkedHashSet = new LinkedHashSet<>();
        
        // Thêm phần tử
        linkedHashSet.add("C");
        linkedHashSet.add("A");
        linkedHashSet.add("B");
        linkedHashSet.add("D");
        
        // Thứ tự duyệt sẽ là thứ tự chèn: C, A, B, D
        System.out.println("LinkedHashSet (preserves insertion order): " + linkedHashSet);
    }
}
                </code></pre>
                
                <h3>TreeSet</h3>
                <p>
                    TreeSet lưu trữ các phần tử trong cây đỏ-đen (Red-Black Tree), đảm bảo các phần tử được sắp xếp theo thứ tự 
                    tự nhiên hoặc bởi bộ so sánh (Comparator) được cung cấp. Các thao tác thêm, xóa và tìm kiếm là O(log n).
                </p>
                
                <pre><code class="language-java">
import java.util.TreeSet;
import java.util.Set;

public class TreeSetExample {
    public static void main(String[] args) {
        Set<String> treeSet = new TreeSet<>();
        
        // Thêm phần tử
        treeSet.add("C");
        treeSet.add("A");
        treeSet.add("B");
        treeSet.add("D");
        
        // Thứ tự duyệt sẽ là thứ tự tự nhiên: A, B, C, D
        System.out.println("TreeSet (natural ordering): " + treeSet);
        
        // Tìm phần tử nhỏ nhất và lớn nhất
        String first = ((TreeSet<String>) treeSet).first();
        String last = ((TreeSet<String>) treeSet).last();
        
        System.out.println("First element: " + first);
        System.out.println("Last element: " + last);
        
        // Tìm phần tử lớn hơn hoặc bằng "B"
        Set<String> tailSet = ((TreeSet<String>) treeSet).tailSet("B");
        System.out.println("TailSet from B: " + tailSet);
        
        // Tìm phần tử nhỏ hơn "C"
        Set<String> headSet = ((TreeSet<String>) treeSet).headSet("C");
        System.out.println("HeadSet before C: " + headSet);
    }
}
                </code></pre>
                
                <h3>So sánh hiệu suất giữa các Set</h3>
                <table border="1" style="width:100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background-color: #f8f9fa;">
                        <th style="padding: 10px; text-align: left;">Triển khai</th>
                        <th style="padding: 10px; text-align: left;">add/remove/contains</th>
                        <th style="padding: 10px; text-align: left;">Thứ tự</th>
                        <th style="padding: 10px; text-align: left;">Trường hợp sử dụng</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">HashSet</td>
                        <td style="padding: 10px;">O(1)</td>
                        <td style="padding: 10px;">Không đảm bảo thứ tự</td>
                        <td style="padding: 10px;">Khi chỉ cần kiểm tra tồn tại, không quan tâm thứ tự</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">LinkedHashSet</td>
                        <td style="padding: 10px;">O(1)</td>
                        <td style="padding: 10px;">Duy trì thứ tự chèn</td>
                        <td style="padding: 10px;">Khi cần duy trì thứ tự chèn</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">TreeSet</td>
                        <td style="padding: 10px;">O(log n)</td>
                        <td style="padding: 10px;">Sắp xếp theo thứ tự tự nhiên hoặc Comparator</td>
                        <td style="padding: 10px;">Khi cần tập hợp có thứ tự và các thao tác phạm vi (range operations)</td>
                    </tr>
                </table>
                
                <h2>Map và các triển khai</h2>
                <p>
                    Interface Map biểu diễn ánh xạ từ khóa đến giá trị, không cho phép khóa trùng lặp. Mỗi khóa có thể ánh xạ 
                    đến nhiều nhất một giá trị.
                </p>
                
                <h3>HashMap</h3>
                <p>
                    HashMap là triển khai phổ biến nhất của Map, sử dụng bảng băm (hash table). Nó cung cấp hiệu suất hằng số 
                    cho các thao tác cơ bản như get và put (trong điều kiện lý tưởng).
                </p>
                
                <pre><code class="language-java">
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        Map<String, Integer> hashMap = new HashMap<>();
        
        // Thêm cặp key-value
        hashMap.put("Apple", 10);
        hashMap.put("Banana", 20);
        hashMap.put("Orange", 30);
        
        System.out.println("HashMap: " + hashMap);
        
        // Truy cập giá trị bằng khóa
        int appleCount = hashMap.get("Apple");
        System.out.println("Apple count: " + appleCount);
        
        // Kiểm tra khóa tồn tại
        boolean containsBanana = hashMap.containsKey("Banana");
        System.out.println("Contains Banana? " + containsBanana);
        
        // Kiểm tra giá trị tồn tại
        boolean contains20 = hashMap.containsValue(20);
        System.out.println("Contains value 20? " + contains20);
        
        // Cập nhật giá trị
        hashMap.put("Apple", 15); // Ghi đè giá trị cũ
        System.out.println("After update: " + hashMap);
        
        // Xóa cặp key-value
        hashMap.remove("Orange");
        System.out.println("After removal: " + hashMap);
        
        // Duyệt qua các cặp key-value
        System.out.println("Iterating through HashMap:");
        for (Map.Entry<String, Integer> entry : hashMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // Duyệt qua các khóa
        System.out.println("All keys: " + hashMap.keySet());
        
        // Duyệt qua các giá trị
        System.out.println("All values: " + hashMap.values());
    }
}
                </code></pre>
                
                <h3>LinkedHashMap</h3>
                <p>
                    LinkedHashMap kế thừa từ HashMap nhưng duy trì thứ tự chèn của các phần tử thông qua danh sách liên kết đôi.
                </p>
                
                <pre><code class="language-java">
import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapExample {
    public static void main(String[] args) {
        Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
        
        // Thêm cặp key-value
        linkedHashMap.put("C", 30);
        linkedHashMap.put("A", 10);
        linkedHashMap.put("B", 20);
        
        // Thứ tự duyệt sẽ là thứ tự chèn: C, A, B
        System.out.println("LinkedHashMap (preserves insertion order): " + linkedHashMap);
        
        // LRU Cache với LinkedHashMap
        // true cho đối số thứ ba để kích hoạt ordering theo thứ tự truy cập
        Map<String, Integer> lruCache = new LinkedHashMap<>(16, 0.75f, true);
        lruCache.put("A", 10);
        lruCache.put("B", 20);
        lruCache.put("C", 30);
        
        // Truy cập B, đưa B lên cuối danh sách
        lruCache.get("B");
        
        System.out.println("LRU Cache after accessing B: " + lruCache);
        // Output sẽ theo thứ tự: A, C, B (B đã được truy cập gần đây nhất)
    }
}
                </code></pre>
                
                <h3>TreeMap</h3>
                <p>
                    TreeMap là triển khai dựa trên cây đỏ-đen (Red-Black Tree) của NavigableMap. Nó duy trì các khóa theo 
                    thứ tự được sắp xếp và cung cấp thời gian log(n) cho các thao tác containsKey, get, put và remove.
                </p>
                
                <pre><code class="language-java">
import java.util.TreeMap;
import java.util.Map;

public class TreeMapExample {
    public static void main(String[] args) {
        TreeMap<String, Integer> treeMap = new TreeMap<>();
        
        // Thêm cặp key-value
        treeMap.put("C", 30);
        treeMap.put("A", 10);
        treeMap.put("B", 20);
        
        // Thứ tự duyệt sẽ là thứ tự tự nhiên của khóa: A, B, C
        System.out.println("TreeMap (sorted by keys): " + treeMap);
        
        // Lấy khóa đầu tiên và cuối cùng
        String firstKey = treeMap.firstKey();
        String lastKey = treeMap.lastKey();
        System.out.println("First key: " + firstKey);
        System.out.println("Last key: " + lastKey);
        
        // Lấy cặp key-value lớn hơn hoặc bằng "B"
        Map.Entry<String, Integer> ceilingEntry = treeMap.ceilingEntry("B");
        System.out.println("Ceiling entry for 'B': " + ceilingEntry);
        
        // Lấy tất cả các cặp key-value có khóa nhỏ hơn "C"
        Map<String, Integer> headMap = treeMap.headMap("C");
        System.out.println("Head map before 'C': " + headMap);
        
        // Lấy tất cả các cặp key-value có khóa từ "B" trở lên
        Map<String, Integer> tailMap = treeMap.tailMap("B");
        System.out.println("Tail map from 'B': " + tailMap);
    }
}
                </code></pre>
                
                <h3>So sánh hiệu suất giữa các Map</h3>
                <table border="1" style="width:100%; border-collapse: collapse; margin: 20px 0;">
                    <tr style="background-color: #f8f9fa;">
                        <th style="padding: 10px; text-align: left;">Triển khai</th>
                        <th style="padding: 10px; text-align: left;">get/put/remove</th>
                        <th style="padding: 10px; text-align: left;">Thứ tự</th>
                        <th style="padding: 10px; text-align: left;">Trường hợp sử dụng</th>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">HashMap</td>
                        <td style="padding: 10px;">O(1)</td>
                        <td style="padding: 10px;">Không đảm bảo thứ tự</td>
                        <td style="padding: 10px;">Khi cần truy cập nhanh, không quan tâm thứ tự</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">LinkedHashMap</td>
                        <td style="padding: 10px;">O(1)</td>
                        <td style="padding: 10px;">Duy trì thứ tự chèn hoặc thứ tự truy cập</td>
                        <td style="padding: 10px;">Khi cần duy trì thứ tự chèn hoặc triển khai LRU cache</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px;">TreeMap</td>
                        <td style="padding: 10px;">O(log n)</td>
                        <td style="padding: 10px;">Sắp xếp theo khóa</td>
                        <td style="padding: 10px;">Khi cần map có thứ tự và các thao tác phạm vi (range operations)</td>
                    </tr>
                </table>
                
                <h2>Queue, Deque và các triển khai</h2>
                <p>
                    Queue đại diện cho một tập hợp giữ các phần tử trước khi xử lý, tuân thủ nguyên tắc First-In-First-Out (FIFO). 
                    Deque (Double Ended Queue) cho phép chèn và lấy phần tử ở cả hai đầu.
                </p>
                
                <h3>LinkedList (triển khai Queue và Deque)</h3>
                <pre><code class="language-java">
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        
        // Thêm phần tử vào queue
        queue.offer("A");
        queue.offer("B");
        queue.offer("C");
        
        System.out.println("Queue: " + queue);
        
        // Lấy phần tử đầu tiên (không xóa)
        String peek = queue.peek();
        System.out.println("First element (peek): " + peek);
        
        // Lấy và xóa phần tử đầu tiên
        String poll = queue.poll();
        System.out.println("Removed first element: " + poll);
        System.out.println("Queue after poll: " + queue);
    }
}
                </code></pre>
                
                <h3>PriorityQueue</h3>
                <p>
                    PriorityQueue là một queue mà các phần tử được sắp xếp theo thứ tự tự nhiên hoặc bởi một Comparator.
                    Phần tử có độ ưu tiên cao nhất (nhỏ nhất theo thứ tự) được xử lý trước.
                </p>
                
                <pre><code class="language-java">
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Comparator;

public class PriorityQueueExample {
    public static void main(String[] args) {
        // PriorityQueue với thứ tự tự nhiên (tăng dần)
        Queue<Integer> minPQ = new PriorityQueue<>();
        minPQ.offer(5);
        minPQ.offer(2);
        minPQ.offer(8);
        minPQ.offer(1);
        
        System.out.println("Min Priority Queue: " + minPQ); // Không đảm bảo thứ tự hiển thị
        
        // Lấy và xóa các phần tử theo thứ tự ưu tiên
        System.out.print("Polling from Min PQ: ");
        while (!minPQ.isEmpty()) {
            System.out.print(minPQ.poll() + " "); // Sẽ in ra theo thứ tự 1, 2, 5, 8
        }
        System.out.println();
        
        // PriorityQueue với Comparator (giảm dần)
        Queue<Integer> maxPQ = new PriorityQueue<>(Comparator.reverseOrder());
        maxPQ.offer(5);
        maxPQ.offer(2);
        maxPQ.offer(8);
        maxPQ.offer(1);
        
        System.out.print("Polling from Max PQ: ");
        while (!maxPQ.isEmpty()) {
            System.out.print(maxPQ.poll() + " "); // Sẽ in ra theo thứ tự 8, 5, 2, 1
        }
    }
}
                </code></pre>
                
                <h3>ArrayDeque</h3>
                <p>
                    ArrayDeque là một triển khai của Deque dựa trên mảng, cho phép thao tác hiệu quả ở cả hai đầu.
                    Nó nhanh hơn Stack và LinkedList trong hầu hết các trường hợp.
                </p>
                
                <pre><code class="language-java">
import java.util.ArrayDeque;
import java.util.Deque;

public class ArrayDequeExample {
    public static void main(String[] args) {
        Deque<String> arrayDeque = new ArrayDeque<>();
        
        // Thêm phần tử vào đầu và cuối
        arrayDeque.offerFirst("First");
        arrayDeque.offerLast("Last");
        arrayDeque.offerFirst("New First");
        arrayDeque.offerLast("New Last");
        
        System.out.println("ArrayDeque: " + arrayDeque);
        
        // Lấy phần tử ở đầu và cuối (không xóa)
        System.out.println("First element: " + arrayDeque.peekFirst());
        System.out.println("Last element: " + arrayDeque.peekLast());
        
        // Lấy và xóa phần tử ở đầu và cuối
        System.out.println("Remove first: " + arrayDeque.pollFirst());
        System.out.println("Remove last: " + arrayDeque.pollLast());
        
        System.out.println("ArrayDeque after poll: " + arrayDeque);
        
        // Sử dụng như Stack (LIFO)
        Deque<String> stack = new ArrayDeque<>();
        stack.push("A");
        stack.push("B");
        stack.push("C");
        
        System.out.println("Stack (ArrayDeque): " + stack);
        System.out.println("Pop from stack: " + stack.pop()); // Lấy phần tử trên cùng (C)
        System.out.println("Stack after pop: " + stack);
    }
}
                </code></pre>
                
                <h2>Tối ưu hiệu suất với Collections</h2>
                <p>
                    Để sử dụng Java Collections một cách hiệu quả, đây là một số kỹ thuật và mẹo tối ưu hiệu suất:
                </p>
                
                <h3>1. Chọn cấu trúc dữ liệu phù hợp</h3>
                <p>
                    Việc chọn cấu trúc dữ liệu phù hợp là bước đầu tiên và quan trọng nhất để tối ưu hiệu suất. Dựa vào các phân tích 
                    ở trên, hãy chọn cấu trúc dữ liệu phù hợp nhất với tình huống của bạn.
                </p>
                
                <h3>2. Khởi tạo với kích thước ban đầu phù hợp</h3>
                <pre><code class="language-java">
// Khởi tạo với kích thước dự kiến để giảm thiểu việc mở rộng
List<String> list = new ArrayList<>(10000);
Map<String, Integer> map = new HashMap<>(1000, 0.75f);
                </code></pre>
                
                <h3>3. Sử dụng bulk operations</h3>
                <pre><code class="language-java">
// Thêm tất cả các phần tử từ một collection khác
List<String> list1 = new ArrayList<>();
list1.add("A");
list1.add("B");

List<String> list2 = new ArrayList<>();
list2.addAll(list1); // Nhanh hơn thêm từng phần tử

// Chuyển đổi giữa các loại collection
Set<String> set = new HashSet<>(list1); // Chuyển List thành Set

// Xóa nhiều phần tử
list1.removeAll(list2); // Xóa tất cả các phần tử có trong list2
                </code></pre>
                
                <h3>4. Sử dụng streams API cho các thao tác phức tạp</h3>
                <pre><code class="language-java">
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class StreamExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eva");
        
        // Lọc các tên bắt đầu bằng chữ C và chuyển thành chữ hoa
        List<String> filteredNames = names.stream()
            .filter(name -> name.startsWith("C"))
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        
        System.out.println(filteredNames); // [CHARLIE]
        
        // Tìm tên ngắn nhất
        String shortestName = names.stream()
            .min((a, b) -> a.length() - b.length())
            .orElse("");
        
        System.out.println("Shortest name: " + shortestName); // Bob
    }
}
                </code></pre>
                
                <h3>5. Sử dụng các cấu trúc đồng bộ hóa một cách cẩn thận</h3>
                <pre><code class="language-java">
import java.util.*;
import java.util.concurrent.*;

public class ConcurrentCollectionsExample {
    public static void main(String[] args) {
        // Collections đồng bộ hóa truyền thống
        List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());
        Map<String, Integer> synchronizedMap = Collections.synchronizedMap(new HashMap<>());
        
        // Concurrent collections từ java.util.concurrent
        List<String> copyOnWriteArrayList = new CopyOnWriteArrayList<>(); // Thread-safe, thích hợp khi đọc nhiều hơn ghi
        Map<String, Integer> concurrentHashMap = new ConcurrentHashMap<>(); // Hiệu suất cao hơn synchronizedMap
        Queue<String> concurrentLinkedQueue = new ConcurrentLinkedQueue<>(); // Queue không chặn
        BlockingQueue<String> linkedBlockingQueue = new LinkedBlockingQueue<>(); // Queue hỗ trợ các thao tác chặn
    }
}
                </code></pre>
                
                <h2>Kết luận</h2>
                <p>
                    Java Collections Framework cung cấp một tập hợp phong phú các cấu trúc dữ liệu cho nhiều tình huống khác nhau. 
                    Việc hiểu rõ về từng cấu trúc, đặc điểm và hiệu suất của chúng sẽ giúp bạn đưa ra quyết định đúng đắn khi 
                    thiết kế và phát triển ứng dụng.
                </p>
                
                <p>
                    Tóm tắt các điểm chính:
                </p>
                <ul>
                    <li>Sử dụng ArrayList khi cần truy cập ngẫu nhiên nhanh chóng</li>
                    <li>Sử dụng LinkedList khi cần chèn/xóa thường xuyên ở đầu/cuối</li>
                    <li>Sử dụng HashSet khi cần tập hợp không trùng lặp và không quan tâm thứ tự</li>
                    <li>Sử dụng LinkedHashSet khi cần duy trì thứ tự chèn</li>
                    <li>Sử dụng TreeSet khi cần tập hợp được sắp xếp</li>
                    <li>Sử dụng HashMap khi cần ánh xạ key-value hiệu quả</li>
                    <li>Sử dụng LinkedHashMap khi cần duy trì thứ tự chèn hoặc truy cập</li>
                    <li>Sử dụng TreeMap khi cần map có thứ tự và các thao tác phạm vi</li>
                    <li>Sử dụng PriorityQueue khi cần queue có ưu tiên</li>
                    <li>Sử dụng ArrayDeque thay cho Stack và như một triển khai hiệu quả của Deque</li>
                </ul>
                
                <p>
                    Hiểu và áp dụng đúng Java Collections Framework sẽ giúp bạn viết code hiệu quả hơn, sạch hơn và 
                    dễ bảo trì hơn trong các dự án Java của mình.
                </p>
                
                <div class="post-tags">
                    <span>#Java</span>
                    <span>#Collections</span>
                    <span>#DataStructures</span>
                    <span>#Performance</span>
                    <span>#Programming</span>
                </div>
                
                <div class="post-navigation">
                    <a href="post-5.html" class="btn btn-secondary"><i class="fas fa-arrow-left"></i> Bài trước</a>
                    <a href="post-7.html" class="btn btn-primary">Bài tiếp theo <i class="fas fa-arrow-right"></i></a>
                </div>
            </div>
            
            <div class="author-section">
                <div class="author-avatar">
                    <img src="../images/profile.jpg" alt="Bùi Dương Tin">
                </div>
                <div class="author-info">
                    <h3>Bùi Dương Tin</h3>
                    <p>Lập trình viên với hơn 5 năm kinh nghiệm phát triển ứng dụng Java và JavaScript. Chuyên sâu về lập trình mạng và các công nghệ web hiện đại.</p>
                    <div class="social">
                        <a href="#" target="_blank"><i class="fab fa-github"></i></a>
                        <a href="#" target="_blank"><i class="fab fa-linkedin"></i></a>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Related Posts -->
    <section class="related-posts">
        <div class="container">
            <h2>Bài viết liên quan</h2>
            <div class="posts-grid">
                <div class="post-card">
                    <div class="post-img">
                        <img src="../images/post-3.jpg" alt="RESTful API">
                        <div class="post-category">Java</div>
                    </div>
                    <div class="post-content">
                        <h3><a href="post-3.html">Xây dựng RESTful API với Spring Boot</a></h3>
                        <div class="post-meta">
                            <span><i class="far fa-calendar"></i> 05/10/2025</span>
                            <span><i class="far fa-clock"></i> 20 phút đọc</span>
                        </div>
                        <p>Hướng dẫn từng bước cách tạo RESTful API với Spring Boot, cách xử lý các request và response, validation...</p>
                        <a href="post-3.html" class="read-more">Đọc tiếp <i class="fas fa-arrow-right"></i></a>
                    </div>
                </div>

                <div class="post-card">
                    <div class="post-img">
                        <img src="../images/post-4.jpg" alt="Java Multithreading">
                        <div class="post-category">Java</div>
                    </div>
                    <div class="post-content">
                        <h3><a href="post-4.html">Lập trình đa luồng trong Java và ứng dụng trong mạng</a></h3>
                        <div class="post-meta">
                            <span><i class="far fa-calendar"></i> 28/09/2025</span>
                            <span><i class="far fa-clock"></i> 18 phút đọc</span>
                        </div>
                        <p>Tìm hiểu về lập trình đa luồng trong Java, synchronization, thread pools và ứng dụng trong phát triển server...</p>
                        <a href="post-4.html" class="read-more">Đọc tiếp <i class="fas fa-arrow-right"></i></a>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <a href="../index.html">BDT<span>Code</span></a>
                    <p>Blog chia sẻ kiến thức lập trình Java và JavaScript, hướng dẫn phát triển ứng dụng mạng.</p>
                </div>
                <div class="footer-links">
                    <h3>Liên kết nhanh</h3>
                    <ul>
                        <li><a href="../index.html">Trang chủ</a></li>
                        <li><a href="../blog.html">Blog</a></li>
                    </ul>
                </div>
                <div class="footer-contact">
                    <h3>Liên hệ</h3>
                    <p><i class="fas fa-envelope"></i> info@buiduongtin.com</p>
                    <p><i class="fas fa-phone"></i> +84 123 456 789</p>
                    <div class="social">
                        <a href="#" target="_blank"><i class="fab fa-github"></i></a>
                        <a href="#" target="_blank"><i class="fab fa-linkedin"></i></a>
                        <a href="#" target="_blank"><i class="fab fa-facebook"></i></a>
                        <a href="#" target="_blank"><i class="fab fa-youtube"></i></a>
                    </div>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Bùi Dương Tin. Tất cả các quyền được bảo lưu.</p>
            </div>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script src="../js/main.js"></script>
</body>
</html>